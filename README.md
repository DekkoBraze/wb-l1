1. Самый эффективный способ конкатенации строк - с помощью операнда "+".

2. Интерфейс - это средство языка, которое позволяет определить, какие методы должна реализовывать структура, чтобы ему соответствовать.
Интерфейсы полезны, когда неизвестно, с какой структурой придется работать, либо это неважно и главное, чтобы она реализовывала определенный функционал.

3. RWMutex отличается от Mutex тем, что позволяет реализовать параллельное чтение - при RLock() блокируются только горутины с Lock(), но другие горутины с RLock() продолжают работать.

4. Небуферизированные каналы позволяют передавать и хранить неограниченное количество данных, в то время как буферизированные - установленный максимум.

5. Размер struct{}{} - 0 байт.

6. В Golang нереализована перегрузка методов и операторов. Это сделано для того, чтобы не перегружать язык (:D).

7. Элементы в map не выводятся в хронологическом порядке, т. к. map не сортирует ключи. Мы можем вывести элементы map в хронологическом порядке, передав ключи в список, отсортировав его и отобразив по нему элементы map.

8. Разница между make и new в том, что make используется для создания map, slice и channel и возвращает значение, а new используется для резервировании памяти для любого типа и возвращает указатель.

9. Существует 2 способа задать map и slice: с помощью композитного литерала и с помощью make.

10. Программа выведет 1 и 1, т. к. указатель передался в функцию по значению (был скопирован), поэтому изменение указателя в ней не приведет к изменению указателя во внешней функции main.
Если все-таки нужно изменить значение указателя p внутри функции, можно присвоить адрес указателя на переменную адресу переданного указателя: *p = *&p.

11. Программа выведет числа от 0 до 5 в порядке завершения соответствующих горутин, а после случится дедлок, т. к. sync.WaitGroup был передан в функцию горутины в качестве аргумента и его значение было скопировано.
Таким образом, в каждой горутине свой sync.WaitGroup, и метод завершения горутины вызывается именно на нем, а не на внешнем sync.WaitGroup, из-за чего случается дедлок.

12. Программа выведет 0, т. к. мы переопределяем переменную n в блоке if с помощью ":=". Если нам нужно изменить значение переменной во внешней функции main, стоит использовать "=".

13. Программа выведет [100 2 3 4 5]. Слайс содержит в себе указатель на массив, который и передается в функцию, из-за
чего операция изменения элемента слайса по индексу отразиться на слайсе в main. Однако, операция append не отразиться на слайсе в main, т. к. она создаст новый слайс, который
будет указывать на новый массив.

14. Программа выведет [b b a][a a]. Тут то же самое, что и в предыдущем пункте - при операции append создается новый слайс, который указывает на новый массив в памяти,
и т. к. слайс не был передан по указателю, новый слайс не был присвоен слайсу из main.
