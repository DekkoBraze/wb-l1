1. Самый эффективный способ конкатенации строк - с помощью операнда "+".

2. Интерфейс - это средство языка, которое позволяет определить, какие методы должна реализовывать структура, чтобы ему соответствовать.
Интерфейсы полезны, когда неизвестно, с какой структурой придется работать, либо это неважно и главное, чтобы она реализовывала определенный функционал.

3. RWMutex отличается от Mutex тем, что позволяет реализовать параллельное чтение - при RLock() блокируются только горутины с Lock(), но другие горутины с RLock() продолжают работать.

4. Небуферизированные каналы позволяют передавать и хранить неограниченное количество данных, в то время как буферизированные - установленный максимум.

5. Размер struct{}{} - 0 байт.

6. В Golang нереализована перегрузка методов и операторов. Это сделано для того, чтобы не перегружать язык (:D).

7. Элементы в map не выводятся в хронологическом порядке, т. к. map не сортирует ключи. Мы можем вывести элементы map в хронологическом порядке, передав ключи в список, отсортировав его и отобразив по нему элементы map.

8. Разница между make и new в том, что make используется для создания map, slice и channel и возвращает значение, а new используется для резервировании памяти для любого типа и возвращает указатель.

9. Существует 2 способа задать map и slice: с помощью композитного литерала и с помощью make.

10. Программа выведет 1 и 1, т. к. указатель передался в функцию по значению (был скопирован), поэтому изменение указателя в ней не приведет к изменению указателя во внешней функции main.
Если все-таки нужно изменить значение указателя p внутри функции, можно присвоить адрес указателя на переменную адресу переданного указателя: *p = *&p.

11. Программа выведет числа от 0 до 5 в порядке завершения соответствующих горутин, а после случится дедлок, т. к. sync.WaitGroup был передан в функцию горутины в качестве аргумента и его значение было скопировано.
Таким образом, в каждой горутине свой sync.WaitGroup, и метод завершения горутины вызывается именно на нем, а не на внешнем sync.WaitGroup, из-за чего случается дедлок.
